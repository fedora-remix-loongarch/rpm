From bc5990647ad94fcb4acdb68612e16fe514ee59b7 Mon Sep 17 00:00:00 2001
From: Mark Wielaard <mark@klomp.org>
Date: Thu, 29 Jun 2017 13:26:24 +0200
Subject: [PATCH 51/54] Extract package file list processing in separate
 functions.

Extract two functions resetPackageFilesDefaults() and addPackageFileList()
from processPackageFiles(). This will make it possible to add multiple
(generated) file lists to a package later.

Signed-off-by: Mark Wielaard <mark@klomp.org>
(cherry picked from commit 139d62d3b8068b0e39893babf13f0c3cc5329e75)
---
 build/files.c | 170 ++++++++++++++++++++++++++++++++++++----------------------
 1 file changed, 107 insertions(+), 63 deletions(-)

diff --git a/build/files.c b/build/files.c
index e93efebd7..8baf85e9d 100644
--- a/build/files.c
+++ b/build/files.c
@@ -2307,45 +2307,35 @@ static void processSpecialDir(rpmSpec spec, Package pkg, FileList fl,
     freeStringBuf(docScript);
     free(mkdocdir);
 }
-				
 
-static rpmRC processPackageFiles(rpmSpec spec, rpmBuildPkgFlags pkgFlags,
-				 Package pkg, int installSpecialDoc, int test)
+
+/* Resets the default settings for files in the package list.
+   Used in processPackageFiles whenever a new set of files is added. */
+static void resetPackageFilesDefaults (struct FileList_s *fl,
+				       rpmBuildPkgFlags pkgFlags)
 {
     struct AttrRec_s root_ar = { 0, 0, 0, 0, 0, 0 };
-    struct FileList_s fl;
-    ARGV_t fileNames = NULL;
-    specialDir specialDoc = NULL;
-    specialDir specialLic = NULL;
 
-    pkg->cpioList = NULL;
+    root_ar.ar_user = rpmstrPoolId(fl->pool, "root", 1);
+    root_ar.ar_group = rpmstrPoolId(fl->pool, "root", 1);
+    dupAttrRec(&root_ar, &fl->def.ar);	/* XXX assume %defattr(-,root,root) */
 
-    for (ARGV_const_t fp = pkg->fileFile; fp && *fp != NULL; fp++) {
-	if (readFilesManifest(spec, pkg, *fp))
-	    return RPMRC_FAIL;
-    }
-    /* Init the file list structure */
-    memset(&fl, 0, sizeof(fl));
-
-    fl.pool = rpmstrPoolLink(spec->pool);
-    /* XXX spec->buildRoot == NULL, then xstrdup("") is returned */
-    fl.buildRoot = rpmGenPath(spec->rootDir, spec->buildRoot, NULL);
-    fl.buildRootLen = strlen(fl.buildRoot);
+    fl->def.verifyFlags = RPMVERIFY_ALL;
 
-    root_ar.ar_user = rpmstrPoolId(fl.pool, "root", 1);
-    root_ar.ar_group = rpmstrPoolId(fl.pool, "root", 1);
-    dupAttrRec(&root_ar, &fl.def.ar);	/* XXX assume %defattr(-,root,root) */
-
-    fl.def.verifyFlags = RPMVERIFY_ALL;
-
-    fl.pkgFlags = pkgFlags;
+    fl->pkgFlags = pkgFlags;
+}
 
-    {	char *docs = rpmGetPath("%{?__docdir_path}", NULL);
-	argvSplit(&fl.docDirs, docs, ":");
-	free(docs);
-    }
-    
-    for (ARGV_const_t fp = pkg->fileList; *fp != NULL; fp++) {
+/* Adds the given fileList to the package. If fromSpecFileList is not zero
+   then the specialDirs are also filled in and the files are sanitized
+   through processBinaryFile(). Otherwise no special files are processed
+   and the files are added directly through addFile().  */
+static void addPackageFileList (struct FileList_s *fl, Package pkg,
+				ARGV_t *fileList,
+				specialDir *specialDoc, specialDir *specialLic,
+				int fromSpecFileList)
+{
+    ARGV_t fileNames = NULL;
+    for (ARGV_const_t fp = *fileList; *fp != NULL; fp++) {
 	char buf[strlen(*fp) + 1];
 	const char *s = *fp;
 	SKIPSPACE(s);
@@ -2355,41 +2345,63 @@ static rpmRC processPackageFiles(rpmSpec spec, rpmBuildPkgFlags pkgFlags,
 	rstrlcpy(buf, s, sizeof(buf));
 	
 	/* Reset for a new line in %files */
-	FileEntryFree(&fl.cur);
+	FileEntryFree(&fl->cur);
 
 	/* turn explicit flags into %def'd ones (gosh this is hacky...) */
-	fl.cur.specdFlags = ((unsigned)fl.def.specdFlags) >> 8;
-	fl.cur.verifyFlags = fl.def.verifyFlags;
-
-	if (parseForVerify(buf, 0, &fl.cur) ||
-	    parseForVerify(buf, 1, &fl.def) ||
-	    parseForAttr(fl.pool, buf, 0, &fl.cur) ||
-	    parseForAttr(fl.pool, buf, 1, &fl.def) ||
-	    parseForDev(buf, &fl.cur) ||
-	    parseForConfig(buf, &fl.cur) ||
-	    parseForLang(buf, &fl.cur) ||
-	    parseForCaps(buf, &fl.cur) ||
-	    parseForSimple(buf, &fl.cur, &fileNames))
+	fl->cur.specdFlags = ((unsigned)fl->def.specdFlags) >> 8;
+	fl->cur.verifyFlags = fl->def.verifyFlags;
+
+	if (parseForVerify(buf, 0, &fl->cur) ||
+	    parseForVerify(buf, 1, &fl->def) ||
+	    parseForAttr(fl->pool, buf, 0, &fl->cur) ||
+	    parseForAttr(fl->pool, buf, 1, &fl->def) ||
+	    parseForDev(buf, &fl->cur) ||
+	    parseForConfig(buf, &fl->cur) ||
+	    parseForLang(buf, &fl->cur) ||
+	    parseForCaps(buf, &fl->cur) ||
+	    parseForSimple(buf, &fl->cur, &fileNames))
 	{
-	    fl.processingFailed = 1;
+	    fl->processingFailed = 1;
 	    continue;
 	}
 
 	for (ARGV_const_t fn = fileNames; fn && *fn; fn++) {
-	    if (fl.cur.attrFlags & RPMFILE_SPECIALDIR) {
-		rpmFlags oattrs = (fl.cur.attrFlags & ~RPMFILE_SPECIALDIR);
+
+	    /* For file lists that don't come from a spec file list
+	       processing is easy. There are no special files and the
+	       file names don't need to be adjusted. */
+	    if (!fromSpecFileList) {
+	        if (fl->cur.attrFlags & RPMFILE_SPECIALDIR
+		    || fl->cur.attrFlags & RPMFILE_DOCDIR
+		    || fl->cur.attrFlags & RPMFILE_PUBKEY) {
+			rpmlog(RPMLOG_ERR,
+			       _("Special file in generated file list: %s\n"),
+			       *fn);
+			fl->processingFailed = 1;
+			continue;
+		}
+		if (fl->cur.attrFlags & RPMFILE_DIR)
+		    fl->cur.isDir = 1;
+		addFile(fl, *fn, NULL);
+		continue;
+	    }
+
+	    /* File list does come from the spec, try to detect special
+	       files and adjust the actual file names.  */
+	    if (fl->cur.attrFlags & RPMFILE_SPECIALDIR) {
+		rpmFlags oattrs = (fl->cur.attrFlags & ~RPMFILE_SPECIALDIR);
 		specialDir *sdp = NULL;
 		if (oattrs == RPMFILE_DOC) {
-		    sdp = &specialDoc;
+		    sdp = specialDoc;
 		} else if (oattrs == RPMFILE_LICENSE) {
-		    sdp = &specialLic;
+		    sdp = specialLic;
 		}
 
 		if (sdp == NULL || **fn == '/') {
 		    rpmlog(RPMLOG_ERR,
 			   _("Can't mix special %s with other forms: %s\n"),
 			   (oattrs & RPMFILE_DOC) ? "%doc" : "%license", *fn);
-		    fl.processingFailed = 1;
+		    fl->processingFailed = 1;
 		    continue;
 		}
 
@@ -2397,32 +2409,65 @@ static rpmRC processPackageFiles(rpmSpec spec, rpmBuildPkgFlags pkgFlags,
 		if (*sdp == NULL) {
 		    *sdp = specialDirNew(pkg->header, oattrs);
 		}
-		addSpecialFile(*sdp, *fn, &fl.cur, &fl.def);
+		addSpecialFile(*sdp, *fn, &fl->cur, &fl->def);
 		continue;
 	    }
 
 	    /* this is now an artificial limitation */
 	    if (fn != fileNames) {
 		rpmlog(RPMLOG_ERR, _("More than one file on a line: %s\n"),*fn);
-		fl.processingFailed = 1;
+		fl->processingFailed = 1;
 		continue;
 	    }
 
-	    if (fl.cur.attrFlags & RPMFILE_DOCDIR) {
-		argvAdd(&(fl.docDirs), *fn);
-	    } else if (fl.cur.attrFlags & RPMFILE_PUBKEY) {
-		(void) processMetadataFile(pkg, &fl, *fn, RPMTAG_PUBKEYS);
+	    if (fl->cur.attrFlags & RPMFILE_DOCDIR) {
+		argvAdd(&(fl->docDirs), *fn);
+	    } else if (fl->cur.attrFlags & RPMFILE_PUBKEY) {
+		(void) processMetadataFile(pkg, fl, *fn, RPMTAG_PUBKEYS);
 	    } else {
-		if (fl.cur.attrFlags & RPMFILE_DIR)
-		    fl.cur.isDir = 1;
-		(void) processBinaryFile(pkg, &fl, *fn);
+		if (fl->cur.attrFlags & RPMFILE_DIR)
+		    fl->cur.isDir = 1;
+		(void) processBinaryFile(pkg, fl, *fn);
 	    }
 	}
 
-	if (fl.cur.caps)
-	    fl.haveCaps = 1;
+	if (fl->cur.caps)
+	    fl->haveCaps = 1;
+    }
+    argvFree(fileNames);
+}
+
+static rpmRC processPackageFiles(rpmSpec spec, rpmBuildPkgFlags pkgFlags,
+				 Package pkg, int installSpecialDoc, int test)
+{
+    struct FileList_s fl;
+    specialDir specialDoc = NULL;
+    specialDir specialLic = NULL;
+
+    pkg->cpioList = NULL;
+
+    for (ARGV_const_t fp = pkg->fileFile; fp && *fp != NULL; fp++) {
+	if (readFilesManifest(spec, pkg, *fp))
+	    return RPMRC_FAIL;
+    }
+    /* Init the file list structure */
+    memset(&fl, 0, sizeof(fl));
+
+    fl.pool = rpmstrPoolLink(spec->pool);
+    /* XXX spec->buildRoot == NULL, then xstrdup("") is returned */
+    fl.buildRoot = rpmGenPath(spec->rootDir, spec->buildRoot, NULL);
+    fl.buildRootLen = strlen(fl.buildRoot);
+
+    resetPackageFilesDefaults (&fl, pkgFlags);
+
+    {	char *docs = rpmGetPath("%{?__docdir_path}", NULL);
+	argvSplit(&fl.docDirs, docs, ":");
+	free(docs);
     }
 
+    addPackageFileList (&fl, pkg, &pkg->fileList,
+			&specialDoc, &specialLic, 1);
+
     /* Now process special docs and licenses if present */
     if (specialDoc)
 	processSpecialDir(spec, pkg, &fl, specialDoc, installSpecialDoc, test);
@@ -2451,7 +2496,6 @@ static rpmRC processPackageFiles(rpmSpec spec, rpmBuildPkgFlags pkgFlags,
     genCpioListAndHeader(&fl, pkg, 0);
 
 exit:
-    argvFree(fileNames);
     FileListFree(&fl);
     specialDirFree(specialDoc);
     specialDirFree(specialLic);
-- 
2.13.2

